---
title: 深入理解java虚拟机之二
date: 2018-11-16 10:46:46
tags: 虚拟机
---

### 对象已死吗？

#### 引用计数算法

1. 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加 1，当引用失效时，计数器值就减 1；任何时刻计数器为 0 的对象就是不能再被使用的。
2. 很难解决对象之间相互循环引用的问题。

#### 可达性分析算法

1. 这个算法的思路就是通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可以用的。
2. GC Roots 的对象包括下面几种：
   1. 虚拟机栈中引用的对象
   2. 方法区中类静态属性引用的对象
   3. 方法区中常量引用的对象
   4. 本地方法栈中 JNI(即一般说的 Native 方法)引用的对象。

**Java 引用**

1. 强引用(Strong Reference): 只要强引用还存在，垃圾收集器永远不会回收掉被应用的对象。
2. 软引用(Soft Reference): 用来描述一些还有用但并非必须的对象。对于软应用关联的对象，在系统将要发生溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。
3. 弱引用(Weak Reference): 也是用来描述非必需对象的，但是他的强度比软引用跟弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
4. 虚引用(Phantom Reference): 也被称为幽灵引用或者幻影引用，它是最弱的一种引用关系。

#### 生存还是死亡

要真正宣告一个对象死亡，至少要经历两次标记过程：

1. 如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那他将会被第一次标记并且进行  一次筛选，筛选的条件时此对象是否有必要执行 finalize()方法，当对象没有覆盖 finalize()方法，或者 finalize()方法已经被虚拟机吊用过，虚拟机将这两种情况都视为“没有必要执行”。
2. 如果这个对象被判定为有必要执行 finalize()方法，那么这个对象将会防止在一个叫做 F-Queue 的队列之中，并在稍后由一个由虚拟机自动建立的、优先级低的 finalize 线程去执行他。finalize 是对象逃脱死亡的命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模标记，如果对象要在 finalize 中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可。

**一个对象的 finalize()方法最多只会被系统自动调用一次**

#### 回收方法区

1. 永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。

类需要满足下面三个条件才算是“无用的类”:

1. 该类所有的实例都已经被回收，也就是 java 堆中不存在该类的任何实例。
2. 加载该类的 ClassLoader 已经被回收
3. 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 垃圾收集算法

#### 标记-清除算法

1. 算法分为标记和清除两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
2. 标记和清除两个过程效率都不高，另一个是空间问题，标记清除之后会产生大量不连续的内存碎片， 空间碎片太多会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

#### 复制算法

1. 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
2. 实现简单，运行高效，只是这种算法的代价是将内存缩小为原来的一半。
3. 将内存分为一块较大的 Eden 区和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor，当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用的 Survivor 空间，HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8:1
4. 当 Survivor 空间不够用时，需要依赖其他内存(这里指老年代)进行分配担保。

#### 标记-整理算法

1. 标记-整理算法，标记过程仍然与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

#### 分代收集算法

1. 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成手机。
2. 老年代中因为对象存活率高,没有额外空间对他进行分配担保，就必须采用“标记-清理”或者“标记-整理”算法来进行回收。

### HotSpot 的算法实现

#### 枚举根节点

在整个分析期间，整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足话分析结果就无法保证准确性，这点是导致 GC 进行时必须停顿所有 Java 执行线程的其中一个重要原因。

当执行系统停顿下来之后，并不需要一个不漏的执行上下文和全局的引用位置，虚拟机应当有办法直接得知哪些地方存放着对象引用。在 Hotspot 虚拟机中，是使用一组称为 OopMap 的数据结构来达到这个目的，在类加载完成的时候，Hotspot 就把对象内什么偏移量上是什么类型的数据计算出来，在 JIT 编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。

#### 安全点

HotSpot 虚拟机没有为每条指令都生成 OopMap。只有在特定的位置记录了这些信息，这些位置称为**安全点**,即程序执行时并非在所有地方都能停顿下来开始 GC，只有在到达安全点时才能暂停。

**安全点(SafePoint)**

1. SafePoint 的选定既不能太少以至于让 GC 等待时间太长，也不能过于频繁以至于过分增大运行时的负荷.
2. 安全点的选定是以是否具有让程序长时间执行的特征为标准进行选定的。长时间执行的最明显特征就是指令序列复用。

对于安全点，另一个需要考虑的问题是如何在 GC 发生时让所有线程都跑到最近的安全点上再停顿下来，这里有两种方案:

1. 抢先式中断：需要线程的执行代码主动去配合，GC 发生时，首先把所有线程全部中断，如果有的线程的中断地方不再安全点上，就恢复线程，让他跑到安全点上，几乎没有虚拟机采用抢先式中断。
2. 主动式中断：当 GC 需要中断线程的时候，不直接对线程操作，仅仅简单的设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志位真时就自己中断挂起，轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。

### 垃圾收集器

#### Serial 收集器

是一个单线程的收集器，在垃圾收集时必须暂停其他所有的工作线程，直到他收集结束。

#### ParNew 收集器

1. 是 Serial 收集器的多线程版本
2. 可以使用-XX：ParallelGCThreads 参数来限制垃圾收集的线程数

> 并行：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
> 并发：指用户线程与垃圾收集线程同时执行，用户程序在继续运行，而垃圾收集程序运行于另一个 CPU 上。

#### Parallel Scavenge 收集器

1. 是一个新生代收集器，也是使用复制算法的收集器，是并行的多线程收集器
2. 吞吐量 = 运行用户代码时间/(运行用户代码时间+垃圾收集时间)
3. -XX:MaxGCPauseMillis 控制最大垃圾收集停顿时间
4. -XX:GCTimeRatio 设置吞吐量大小 值是一个大于 0 且小于 100 的整数
5. -XX:+UseAdaptiveSizePolicy 开关参数，这个参数打开之后，就不需要手工指定新生代的大小

#### Serial Old 收集器

1. 是 Serial 收集器的老年代版本，同样是一个单线程收集器，使用标记-整理算法
2. 给 client 模式下的虚拟机使用

#### Parallel Old 收集器

1. 是 Parallel Scavenge 收集器的老年代版本，使用多线程标记-整理算法。

#### CMS 收集器

1. 以获得最短回收停顿时间为目标的收集器
2. 基于标记-清楚算法实现的。

### G1 收集器

1. G1 是面向服务端应用的垃圾收集器。
2. 并行与并发
3. 分代手机
4. 空间整合：是基于标记-整理算法实现的收集器
5. 可预测的停顿

**G1 收集器的运作分为下面几个步骤**

1. 初始标记
2. 并发标记
3. 最终标记
4. 筛选回收

### 内存分配与回收策略

1. 对象优先在 Eden 分配: 当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。
2. 大对象直接进入老年代
   1. 大对象是指需要大量连续内存空间的 Java 对象，最典型的大对象就是那种很长的字符串以及数组。
3. 长期存活的对象将进入老年代
   1. 虚拟机给每个对象定义了一个对象年龄计数器，如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并且对象年龄设为 1.
   2. 当它的年龄增加到一定程度，就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold 设置。
4. 动态对象年龄判定
    1. 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。
5. 空间分配担保


**Minor GC 和 Full GC**

1. Minor GC(新生代 GC): 指发生在新生代的垃圾收集动作，Minor GC 非常频繁，一般回收速度有比较快。
2. Full GC(老年代 GC): 指发生在老年代的 GC，经常会伴随至少一次的 Minor GC，速度一般会 Minor GC 慢 10 倍以上。
