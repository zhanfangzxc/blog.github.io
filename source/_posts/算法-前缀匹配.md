---
title: 算法-前缀匹配
date: 2018-11-30 17:00:37
tags: 算法
---

### 题目

```
假如要做一个字典应用，希望用户在输入字母的时候，自动给出前缀匹配的词。例如：

当用户输入：
sma

给出建议单词：
sma
smaak
smack
smaik
small
smalm
smalt
smarm
smart

要求一：
给出的单词按匹配度排序，所谓匹配度简单说就是，短的排前面长的排后面，如上例所示。

要求二：
给出的建议单词个数 N 可配置，当字典中的单词数小于 N 时，有多少返回多少。大于 N 时则返回 N 个。

字典在此：
https://raw.githubusercontent.com/words/an-array-of-english-words/master/words.json
```

### 方案一

```javascript
"use strict";

var words;
$.ajax({
  url:
    "https://raw.githubusercontent.com/words/an-array-of-english-words/master/words.json",
  async: false,
  success: function(data) {
    words = JSON.parse(data);
  }
});

const WORDS_INDEX = {};
const WORDS_ASSOCIATION_LENGTH = 3;
const MAX_ASSOCIATION_NUM = 20;

// step1 分组
var str;
for (let i = 0; i < words.length; i++) {
  for (let j = 1; j <= WORDS_ASSOCIATION_LENGTH; j++) {
    if (words[i].length < j) {
      break;
    }

    str = words[i].substr(0, j);

    if (!WORDS_INDEX[str]) {
      WORDS_INDEX[str] = { index: i, num: 1 };
    } else if (WORDS_INDEX[str] > i) {
      WORDS_INDEX[str].index = i;
      WORDS_INDEX[str].num++;
    } else {
      WORDS_INDEX[str].num++;
    }
  }
}

/**
 *
 * @param {*} element
 */
function onKeyUp(element) {
  var date1 = new Date();

  const start = WORDS_INDEX[element.value.substr(0, WORDS_ASSOCIATION_LENGTH)];
  if (!start) {
    $("#association").html("");
    return true;
  }

  var association = [];
  if (element.value.length > WORDS_ASSOCIATION_LENGTH) {
    for (let i = start.index; i < start.index + start.num; i++) {
      if (words[i].indexOf(element.value) === 0) {
        association.push(words[i]);
      }
    }
  } else {
    association = words.slice(start.index, start.index + start.num);
  }

  // step 按长度排序
  association.sort(function(a, b) {
    return a.length - b.length;
  });

  $("#association").html(
    association.slice(0, MAX_ASSOCIATION_NUM).join("<br>")
  );

  var date2 = new Date();
  $("#time").text(`${date2.getTime() - date1.getTime()} ms`);
}

console.log(WORDS_INDEX);
```

#### 方案二： Tire 树

```JAVASCRIPT
onst words = require('./words')

function build(words) {
  let root = {}
  for (let word of words) {
    let letters = word.split('')
    let node = root

    for (let letter of letters) {
      if (!node[letter]) {
        node[letter] = {}
      }
      node = node[letter]
    }

    node.value = word
  }
  return root
}

const tree = build(words)

function search(input, count) {
  const results = []

  function getChildren(node) {
    return Object.keys(node)
      .filter(letter => letter !== 'value')
      .map(letter => node[letter])
  }

  let node = tree
  // find node along letter path
  for (let letter of input) {
    if (!node[letter]) {
      return [] // not found
    }
    node = node[letter]
  }

  if (node.value) {
    results.push(node.value)
  }

  let children = getChildren(node)
  for (let node of children) {
    if (node.value) {
      results.push(node.value)
      if (results.length >= count) {
        return results
      }
    }
    getChildren(node).forEach(node => children.push(node)) // add next level's nodes
  }

  return results
}

let begin = new Date
let results = search(process.argv[2], parseInt( process.argv[3]))
let end = new Date
results.forEach(c => console.log(c))
console.log(`${end - begin} ms, ${results.length} words`)
```

### 方案三：二分查找

```java
private fun start(words: Array<String>, key: String): Int {
        var low = 0
        var high = words.size
        while (low <= high) {
            var middle = (low + high) / 2

            if (words[middle] < key) {
                low = middle + 1
            } else if (words[middle] >= key) {
                if (words[middle - 1] < key) {

                    return middle
                } else {
                    high = middle - 1
                }

            }
        }

        return -1
    }

    private fun end(words: Array<String>, first: Int, n: Int, key: String): Int {
        var low = first
        var high = words.size
        if (words.size > first + n) {
            //第low+n-1个依然满足前缀直接返回
            if ((words[low + n - 1].subSequence(0, key.length).toString()) == key) {
                return low + n - 1
            } else {
                high = low + n - 1 //如果不满足将第n个作为结尾
            }
        }

        while (low <= high) {
            var middle = (low + high) / 2

            if ((words[middle].subSequence(0, key.length).toString()) == key) {
                if ((words[middle + 1].subSequence(0, key.length).toString()) > key) {

                    return middle
                } else {

                    low = middle + 1

                }
            } else if (words[middle].subSequence(0, key.length).toString() > key) {
                high = middle - 1

            }
        }
        return -1
    }

```
